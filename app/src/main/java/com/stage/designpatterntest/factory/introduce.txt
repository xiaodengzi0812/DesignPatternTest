工厂设计模式：
    需求： 小明今天想办一个屌丝证，如何实现呢？ 明天又想办一个脑残证呢？

    第一种解决办法： 小明必须了解屌丝证所有办证过程，然后亲自办理一个屌丝证。脑残证以此类推（亲自操刀，费时，费力）
    第二种解决办法： 小明必须找到专业的屌丝证办证人员，然后让专业人员办理一个屌丝证。脑残证也必须去找专业的办证人员（小明必须知道办证人员联系方式、工作地址等等信息。如果办证人员信息有所变动那将会导致所有要办屌丝证的人去做一些信息更新）
    第三种解决办法： 小明找到办证大厅，然后只要找到对应的办证窗口即可拿到想要的证书。（小明只要找到办证大厅就够了，想要办什么证书只要在对应的窗口排队即可，他并不需要知道是谁办这个证，也不用担心办证人员会有什么变动）

    在这里办证大厅就相当于一个工厂，这个工厂将很多类似的办证业务都集中到一起，只需要提供一个证书名即可办理对应的证书。

    优点： 1、小明现在只需要依赖办证窗口（接口），并不依赖于办证人员（实现类）。
           2、小明又想办脑残证了，只需要到对应的窗口排队即可，不需要再做过多的动作（如果有新业务需要，只需要新增工厂接口实现类即可，方便扩展）
           3、后台办证人员更换几乎与小明没有一毛钱的关系（解耦）

    缺点：如果办理的证书越来越多，会导致类越来越多（类爆炸）


	工厂方法模式可以让客户在实例化对象时,只依赖接口,而不依赖具体的实现类。这符合“针对接口编程,而不是针对实现编程”的软件设计原则。
	
	工厂方法用来处理对象的创建,并将这样的行为封装在子类中。这样,客户程序中关于超类的代码就和子类对象的创建代码解耦(Decouple)了
	
	
	软件设计原则:要依赖抽象,不要依赖具体类。这个原则又被称为“依赖倒置原则(Dependency Inversion Principle)”。
		依赖倒置原则说明不能让高层组件依赖于底层组件,而且它们都应该依赖于抽象。
	遵循依赖倒置原则的三个指导方针:
		(1)变量不可以持有具体类的引用。这可以通过使用工厂避开。
		(2)不要让类派生自具体类。否则就会依赖具体类,违反了“针对接口编程,而不是针对现实编程”的软件设计原则。
		(3)不要覆盖基类中已实现的方法。出现这样的情况就说明基类设计的有问题。